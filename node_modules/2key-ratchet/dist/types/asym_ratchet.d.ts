/**
 *
 * 2key-ratchet
 * Copyright (c) 2016 Peculiar Ventures, Inc
 * Based on https://whispersystems.org/docs/specifications/doubleratchet/ and
 * https://whispersystems.org/docs/specifications/x3dh/ by Open Whisper Systems
 *
 */
/// <reference types="node" />
import { EventEmitter } from "events";
import { ECPublicKey, IECKeyPair } from "./crypto";
import { Identity } from "./data";
import { RemoteIdentity } from "./data/remote_identity";
import { MessageSignedProtocol, PreKeyBundleProtocol, PreKeyMessageProtocol } from "./protocol";
import { Stack } from "./stack";
import { ReceivingRatchet, SendingRatchet } from "./sym_ratchet";
import { IJsonReceivingRatchet, IJsonSymmetricRatchet } from "./sym_ratchet";
import { IJsonSerializable } from "./type";
import { ECDHPrivateKey, HMACCryptoKey } from "./type";
export interface IJsonAsymmetricRatchet {
    remoteIdentity: string;
    ratchetKey: CryptoKeyPair;
    counter: number;
    rootKey: CryptoKey;
    steps: IJsonDHRatchetStep[];
}
export interface IAsymmetricRatchetOptions {
    exportableKeys?: boolean;
}
/**
 * Implementation Diffie-Hellman ratchet
 * https://whispersystems.org/docs/specifications/doubleratchet/#diffie-hellman-ratchet
 *
 * @export
 * @class AsymmetricRatchet
 */
export declare class AsymmetricRatchet extends EventEmitter implements IJsonSerializable {
    options: IAsymmetricRatchetOptions;
    /**
     * Creates new ratchet for given identity from PreKeyBundle or PreKey messages
     *
     * @static
     * @param {Identity} identity
     * @param {(PreKeyBundleProtocol | PreKeyMessageProtocol)} protocol
     * @returns
     *
     * @memberOf AsymmetricRatchet
     */
    static create(identity: Identity, protocol: PreKeyBundleProtocol | PreKeyMessageProtocol, options?: IAsymmetricRatchetOptions): Promise<AsymmetricRatchet>;
    static fromJSON(identity: Identity, remote: RemoteIdentity, obj: IJsonAsymmetricRatchet): Promise<AsymmetricRatchet>;
    id: number;
    rootKey: HMACCryptoKey;
    identity: Identity;
    remoteIdentity: RemoteIdentity;
    remotePreKeyId?: number;
    remotePreKeySignedId: number;
    counter: number;
    currentStep: DHRatchetStep;
    currentRatchetKey: IECKeyPair;
    protected steps: DHRatchetStepStack;
    protected promises: {
        [key: string]: Promise<any>;
    };
    protected constructor(options?: IAsymmetricRatchetOptions);
    on(event: "update", listener: () => void): this;
    once(event: "update", listener: () => void): this;
    /**
     * Verifies and decrypts data from SignedMessage
     *
     * @param {MessageSignedProtocol} protocol
     * @returns
     *
     * @memberOf AsymmetricRatchet
     */
    decrypt(protocol: MessageSignedProtocol): Promise<ArrayBuffer>;
    /**
     * Encrypts message
     *
     * @param {ArrayBuffer} message
     * @returns
     *
     * @memberOf AsymmetricRatchet
     */
    encrypt(message: ArrayBuffer): Promise<MessageSignedProtocol | PreKeyMessageProtocol>;
    hasRatchetKey(key: CryptoKey | ECPublicKey): Promise<boolean>;
    toJSON(): Promise<IJsonAsymmetricRatchet>;
    fromJSON(obj: IJsonAsymmetricRatchet): Promise<void>;
    protected update(): void;
    /**
     * Generate new ratchet key
     *
     * @protected
     * @returns
     *
     * @memberOf AsymmetricRatchet
     */
    protected generateRatchetKey(): Promise<IECKeyPair>;
    /**
     * Creates new symmetric ratchet
     *
     * @protected
     * @param {ECDHPrivateKey} ourRatchetKey
     * @param {ECPublicKey} theirRatchetKey
     * @param {typeof ReceivingRatchet} ratchetClass
     * @returns {Promise<ReceivingRatchet>}
     *
     * @memberOf AsymmetricRatchet
     */
    protected createChain(ourRatchetKey: ECDHPrivateKey, theirRatchetKey: ECPublicKey, ratchetClass: typeof ReceivingRatchet): Promise<ReceivingRatchet>;
    protected createChain(ourRatchetKey: ECDHPrivateKey, theirRatchetKey: ECPublicKey, ratchetClass: typeof SendingRatchet): Promise<SendingRatchet>;
    protected queuePromise<T>(key: string, fn: () => Promise<T>): Promise<T>;
}
export interface IJsonDHRatchetStep {
    remoteRatchetKey?: CryptoKey;
    sendingChain?: IJsonSymmetricRatchet;
    receivingChain?: IJsonReceivingRatchet;
}
/**
 * Implementation of step of the Diffie-Hellman ratchet
 *
 * @export
 * @class DHRatchetStep
 */
export declare class DHRatchetStep implements IJsonSerializable {
    static fromJSON(obj: IJsonDHRatchetStep): Promise<DHRatchetStep>;
    /**
     * Remote client's ratchet key
     *
     * @type {ECPublicKey}
     * @memberOf DHRatchetStep
     */
    remoteRatchetKey?: ECPublicKey;
    /**
     * Sending chain
     *
     * @type {SendingRatchet}
     * @memberOf DHRatchetStep
     */
    sendingChain?: SendingRatchet;
    /**
     * Receiving chain
     *
     * @type {ReceivingRatchet}
     * @memberOf DHRatchetStep
     */
    receivingChain?: ReceivingRatchet;
    toJSON(): Promise<IJsonDHRatchetStep>;
    fromJSON(obj: IJsonDHRatchetStep): Promise<void>;
}
/**
 * Implements collection of DHRatchetStep
 *
 * @export
 * @class DHRatchetStepStack
 * @extends {Stack<DHRatchetStep>}
 */
export declare class DHRatchetStepStack extends Stack<DHRatchetStep> {
    /**
     * Returns DHRatchetStep by given remote client's ratchet key
     * @param {ECPublicKey} remoteRatchetKey remote client's ratchet key
     * @returns
     *
     * @memberOf DHRatchetStepStack
     */
    getStep(remoteRatchetKey: ECPublicKey): DHRatchetStep | undefined;
}
