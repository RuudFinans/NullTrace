/**
 *
 * 2key-ratchet
 * Copyright (c) 2016 Peculiar Ventures, Inc
 * Based on https://whispersystems.org/docs/specifications/doubleratchet/ and
 * https://whispersystems.org/docs/specifications/x3dh/ by Open Whisper Systems
 *
 */
import { HMACCryptoKey, ISymmetricKDFResult } from "./type";
import { IJsonSerializable } from "./type";
/**
 * Encrypt/Decrypt result for Symmetric ratchets
 *
 * @export
 * @interface CipherMessage
 */
export interface ICipherMessage {
    /**
     * Encrypted or decrypted message
     */
    cipherText: ArrayBuffer;
    /**
     * HMAC key for SignedMessage calculations
     */
    hmacKey: CryptoKey;
}
export interface IJsonSymmetricRatchet {
    counter: number;
    rootKey: CryptoKey;
}
export declare abstract class SymmetricRatchet implements IJsonSerializable {
    static fromJSON<T extends SymmetricRatchet>(this: new (rootKey: CryptoKey) => T, obj: IJsonSymmetricRatchet): Promise<T>;
    counter: number;
    /**
     * Current symmetric ratchet key
     */
    rootKey: HMACCryptoKey;
    constructor(rootKey: CryptoKey);
    toJSON(): Promise<IJsonSymmetricRatchet>;
    fromJSON(obj: IJsonSymmetricRatchet): Promise<void>;
    /**
     * calculates new keys by rootKey KDF_CK(ck)
     * https://whispersystems.org/docs/specifications/doubleratchet/#external-functions
     *
     * @protected
     * @param {CryptoKey} rootKey
     * @returns
     *
     * @memberOf SymmetricRatchet
     */
    protected calculateKey(rootKey: CryptoKey): Promise<ISymmetricKDFResult>;
    /**
     * Move to next step of ratchet
     *
     * @protected
     * @returns
     *
     * @memberOf SymmetricRatchet
     */
    protected click(): Promise<ArrayBuffer>;
}
/**
 * Implementation of Sending chain
 *
 * @export
 * @class SendingRatchet
 * @extends {SymmetricRatchet}
 */
export declare class SendingRatchet extends SymmetricRatchet {
    /**
     * Encrypts message
     *
     * @param {ArrayBuffer} message
     * @returns CipherMessage type
     *
     * @memberOf SendingRatchet
     */
    encrypt(message: ArrayBuffer): Promise<ICipherMessage>;
}
export interface IJsonReceivingRatchet extends IJsonSymmetricRatchet {
    keys: ArrayBuffer[];
}
export declare class ReceivingRatchet extends SymmetricRatchet {
    protected keys: ArrayBuffer[];
    toJSON(): Promise<IJsonReceivingRatchet>;
    fromJSON(obj: IJsonReceivingRatchet): Promise<void>;
    decrypt(message: ArrayBuffer, counter: number): Promise<ICipherMessage>;
    protected getKey(counter: number): Promise<ArrayBuffer>;
}
