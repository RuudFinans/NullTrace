'use strict';

var pvtsutils = require('pvtsutils');
var protobufjs = require('protobufjs');

class ArrayBufferConverter {
    static async set(value) {
        return new Uint8Array(value);
    }
    static async get(value) {
        return new Uint8Array(value).buffer;
    }
}
class StringConverter {
    static async set(value) {
        return new Uint8Array(pvtsutils.Convert.FromUtf8String(value));
    }
    static async get(value) {
        return pvtsutils.Convert.ToUtf8String(value);
    }
}

function ProtobufElement(params) {
    return (target) => {
        const t = target;
        t.localName = params.name || t.name || t.toString().match(/^function\s*([^\s(]+)/)[1];
        t.items = t.items || {};
        t.target = target;
        t.items = pvtsutils.assign({}, t.items);
        const scheme = new protobufjs.Type(t.localName);
        for (const key in t.items) {
            const item = t.items[key];
            let rule = void 0;
            if (item.repeated) {
                rule = "repeated";
            }
            else if (item.required) {
                rule = "required";
            }
            scheme.add(new protobufjs.Field(item.name, item.id, item.type, rule));
        }
        t.protobuf = scheme;
    };
}
function defineProperty(target, key, params) {
    const propertyKey = `_${key}`;
    const opt = {
        set: function (v) {
            if (this[propertyKey] !== v) {
                this.raw = null;
                this[propertyKey] = v;
            }
        },
        get: function () {
            if (this[propertyKey] === void 0) {
                let defaultValue = params.defaultValue;
                if (params.parser && !params.repeated) {
                    defaultValue = new params.parser();
                }
                this[propertyKey] = defaultValue;
            }
            return this[propertyKey];
        },
        enumerable: true,
    };
    Object.defineProperty(target, propertyKey, { writable: true, enumerable: false });
    Object.defineProperty(target, key, opt);
}
function ProtobufProperty(params) {
    return (target, propertyKey) => {
        const t = target.constructor;
        const key = propertyKey;
        t.items = t.items || {};
        if (t.target !== t) {
            t.items = pvtsutils.assign({}, t.items);
            t.target = t;
        }
        t.items[key] = {
            id: params.id,
            type: params.type || "bytes",
            defaultValue: params.defaultValue,
            converter: params.converter || null,
            parser: params.parser || null,
            name: params.name || key,
            required: params.required || false,
            repeated: params.repeated || false,
        };
        defineProperty(target, key, t.items[key]);
    };
}

class ObjectProto {
    static async importProto(data) {
        const res = new this();
        await res.importProto(data);
        return res;
    }
    isEmpty() {
        return this.raw === undefined;
    }
    hasChanged() {
        if (this.raw === null) {
            return true;
        }
        const thisStatic = this.constructor;
        const that = this;
        for (const key in thisStatic.items) {
            const item = thisStatic.items[key];
            if (item.repeated) {
                if (item.parser) {
                    return that[key].some((arrayItem) => arrayItem.hasChanged());
                }
            }
            else {
                if (item.parser && that[key] && that[key].hasChanged()) {
                    return true;
                }
            }
        }
        return false;
    }
    async importProto(data) {
        const thisStatic = this.constructor;
        const that = this;
        let scheme;
        let raw;
        if (data instanceof ObjectProto) {
            raw = await data.exportProto();
        }
        else {
            raw = data;
        }
        try {
            if (!thisStatic.protobuf) {
                throw new Error("Protobuf schema doesn't contain 'protobuf' property");
            }
            scheme = thisStatic.protobuf.decode(new Uint8Array(raw));
        }
        catch (e) {
            const err = e instanceof Error ? e : new Error("Unknown error");
            throw new Error(`Cannot decode message for ${thisStatic.localName}.\n$ProtobufError: ${err.message}`);
        }
        for (const key in thisStatic.items) {
            const item = thisStatic.items[key];
            let schemeValues = scheme[item.name];
            if (ArrayBuffer.isView(schemeValues)) {
                schemeValues = new Uint8Array(schemeValues);
            }
            if (!Array.isArray(schemeValues)) {
                if (item.repeated) {
                    that[key] = schemeValues = [];
                }
                else {
                    schemeValues = [schemeValues];
                }
            }
            if (item.repeated && !that[key]) {
                that[key] = [];
            }
            for (const schemeValue of schemeValues) {
                if (item.repeated) {
                    that[key].push(await this.importItem(item, schemeValue));
                }
                else {
                    that[key] = await this.importItem(item, schemeValue);
                }
            }
        }
        this.raw = raw;
    }
    async exportProto() {
        if (!this.hasChanged()) {
            return this.raw;
        }
        const thisStatic = this.constructor;
        const that = this;
        const protobuf = {};
        for (const key in thisStatic.items) {
            const item = thisStatic.items[key];
            let values = that[key];
            if (!Array.isArray(values)) {
                values = values === void 0 ? [] : [values];
            }
            for (const value of values) {
                const protobufValue = await this.exportItem(item, value);
                if (item.repeated) {
                    if (!protobuf[item.name]) {
                        protobuf[item.name] = [];
                    }
                    protobuf[item.name].push(protobufValue);
                }
                else {
                    protobuf[item.name] = protobufValue;
                }
            }
        }
        this.raw = new Uint8Array(thisStatic.protobuf.encode(protobuf).finish()).buffer;
        return this.raw;
    }
    async exportItem(template, value) {
        const thisStatic = this.constructor;
        let result;
        if (template.parser) {
            const obj = value;
            const raw = await obj.exportProto();
            if (template.required && !raw) {
                throw new Error(`Parameter '${template.name}' is required in '${thisStatic.localName}' protobuf message.`);
            }
            if (raw) {
                result = new Uint8Array(raw);
            }
        }
        else {
            if (template.required && value === undefined) {
                throw new Error(`Parameter '${template.name}' is required in '${thisStatic.localName}' protobuf message.`);
            }
            if (template.converter) {
                if (value !== undefined) {
                    result = await template.converter.set(value);
                }
            }
            else {
                if (value instanceof ArrayBuffer) {
                    value = new Uint8Array(value);
                }
                result = value;
            }
        }
        return result;
    }
    async importItem(template, value) {
        const thisStatic = this.constructor;
        let result;
        if (template.parser) {
            const parser = template.parser;
            if (value && value.byteLength) {
                result = await parser.importProto(new Uint8Array(value).buffer);
            }
            else if (template.required) {
                throw new Error(`Parameter '${template.name}' is required in '${thisStatic.localName}' protobuf message.`);
            }
        }
        else if (template.converter) {
            if (value && value.byteLength) {
                result = await template.converter.get(value);
            }
            else if (template.required) {
                throw new Error(`Parameter '${template.name}' is required in '${thisStatic.localName}' protobuf message.`);
            }
        }
        else {
            result = value;
        }
        return result;
    }
}

exports.ArrayBufferConverter = ArrayBufferConverter;
exports.ObjectProto = ObjectProto;
exports.ProtobufElement = ProtobufElement;
exports.ProtobufProperty = ProtobufProperty;
exports.StringConverter = StringConverter;
